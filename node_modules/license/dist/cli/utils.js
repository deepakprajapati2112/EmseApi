"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const git_config_path_1 = __importDefault(require("git-config-path"));
const parse_git_config_1 = require("parse-git-config");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const _1 = require(".");
/**
 * Test if a string is a valid npm package name.
 * Sort of a port of is-valid-npm-name but without the dependencies
 */
function isNpmPackageName(str) {
    return !(
    // musn't be blank
    (!str ||
        // can't have leading or trailing whitespace
        str.trim() !== str ||
        // can't be longer than 214 chars
        str.length > 214 ||
        // can't start with `.` or `_`
        [".", "_"].includes(str[0]) ||
        // can't have uppercase
        str !== str.toLowerCase() ||
        // scope checks
        (str.startsWith("@") &&
            !(
            // can't have multiple `@`
            (str.indexOf("@") !== str.lastIndexOf("@") ||
                // needs to have a separating slash
                !str.includes("/") ||
                // can't have multiple `/`
                str.indexOf("/") !== str.lastIndexOf("/") ||
                // recursive check both parts of the scopes name
                isNpmPackageName(str.split("/")[0].slice(1)) ||
                isNpmPackageName(str.split("/")[1])))) ||
        // needs to be url safe
        encodeURIComponent(str) !== str));
}
exports.isNpmPackageName = isNpmPackageName;
function isAcceptedYear(str) {
    const split = str.split("-");
    return (
    // standalone year (2004)
    /^\d{4}$/.test(str) ||
        // year range (2004-2010)
        (split.length === 2 && split.every(x => /^\d{4}$/.test(x))) ||
        // list of years (2001, 2002-2005, 2007)
        (/, ?/.test(str) &&
            // recurse to allow ranges or standalone years in the list
            str
                .split(",")
                .map(x => x.trim())
                .every(isAcceptedYear)));
}
exports.isAcceptedYear = isAcceptedYear;
/** Resolve a path, including the expansion of `~/` paths */
const expandPath = (path_) => path_1.default.resolve(path_.replace(/^~(?=$|\/|\\)/, os_1.default.homedir()));
exports.convertProject = (str) => ({
    path: expandPath(str),
    name: path_1.default.basename(expandPath(str))
});
exports.nonEmpty = (name) => (val) => {
    if (val === "")
        throw new TypeError(`${name} cannot be empty`);
    else
        return val;
};
const gitConfig = () => parse_git_config_1.sync({ cwd: "/", path: git_config_path_1.default("global") });
exports.getUserName = () => { var _a; return _1.cfg.get("name") || ((_a = gitConfig().user) === null || _a === void 0 ? void 0 : _a.name) || process.env.USER; };
exports.getUserEmail = () => { var _a; return _1.cfg.get("email") || ((_a = gitConfig().user) === null || _a === void 0 ? void 0 : _a.email); };
//# sourceMappingURL=utils.js.map